#!/usr/bin/python
"""
Profile a command, giving max/avg threads, mem, i/o, etc..
"""

#import collections
import subprocess
import argparse
import sys
import time

import pprint
import psutil

pp = pprint.PrettyPrinter(indent=2, depth=3)


## Config

DEFAULTS = {
    'poll_wait': .1,
    'cpu_threshold': .01,
    'max_polls': 0,
    'min_polls': 5,
    'verbosity': 1,
    }
ARGS = None


## Classes

class Profiler(object):
    """Profiler class"""
    popen = None
    pid = None
    cmd = None
    process = None
    proc_infos = []
    proc_info_summary = {}
    rollup = {}
    num_polls = 0

    exclude = [
        'cmdline',
        'cpu_affinity',
        'create_time',
        'cwd',
        'exe',
        'gids',
        'name',
        'ppid',
        'status',
        'terminal',
        'uids',
        'username',
        'nice',
        'ionice',
        ]

    def __init__(self, **kwargs):
        if 'cmd' in kwargs:
            self.cmd = kwargs['cmd']
        elif 'pid' in kwargs:
            self.pid = kwargs['pid']
            self.process = psutil.Process(self.pid)


    def run(self):
        """Run our command"""
        print "Executing {0}".format(self.cmd)
        self.popen = subprocess.Popen(self.cmd, shell=True, stderr=None, stdout=None, stdin=None)
        if self.popen.pid:
            self.pid = self.popen.pid
            self.process = psutil.Process(self.pid)


    def watch(self):
        """Watch our process"""

        print "Watching command with pid: {0}".format(self.pid)

        while (ARGS.max_polls == 0 or self.num_polls < ARGS.max_polls):
            if self.poll_procs() or self.num_polls < DEFAULTS['min_polls']:
                rollup_dict(self.rollup, self.proc_info_summary)

                #print "self.rollup: {0}".format(pp.pformat(self.rollup['v_threads_running']))
                #print "\n" + "#" * 100 + "\n"
                #pp.pprint(self.rollup)

                #if ARGS.verbosity > 2:
                #    self.report()

                time.sleep(ARGS.poll_wait)
            else:
                break
            sys.stdout.flush()

        print "Process {0} has exited".format(self.pid)

        filter_dict(self.rollup, ['accum', 'num_polls']) 
        self.report()


    def poll_procs(self):
        """Poll the info of the processes"""
        #print "Entered poll_procs"

        self.snapshot_proc_infos()
        self.num_polls += 1

        if len(self.proc_infos) < 1:
            print "Not able to poll processes"
            return False
        else:
            # Merge all proc infos into one object
            proc_info_summary_rollup = {}
            #print "num proc_infos: {0}".format(len(self.proc_infos))
            #print "proc_infos[0]: {0}".format(self.proc_infos[0]['pid'])
            for proc_info in self.proc_infos:
                #print "Accumulating {0} to summary".format(proc_info['pid'])
                #print "proc_info: {0}".format(pp.pformat(proc_info['v_threads_running']))
                rollup_dict(proc_info_summary_rollup, proc_info)
                #print "pi: {0} pisr: {1}".format(proc_info['v_threads_running'], proc_info_summary_rollup['v_threads_running'])

            #pp.pprint(self.proc_info_summary)
            self.proc_info_summary = flatten_dict(proc_info_summary_rollup, ['accum'])
            #print "pis: {0}".format(self.proc_info_summary['num_threads'])

            #pp.pprint(self.proc_info_summary)
            #print "**** proc_infos:"
            #pp.pprint(self.proc_infos)
            #print "**** Summary"
            #pp.pprint(self.proc_info_summary)

            return True


    def report(self):
        """Report on the proc infos and rollups"""

        pp.pprint(self.rollup)
        return

        for aspect, value in self.rollup:
            print "{0}: {1}".format(aspect, pp.pformat(value))


    def snapshot_proc_infos(self):
        """Grab info on all the processes"""

        # Identify all the processes to check
        procs = self.process.children(recursive=True)

        procs.append(self.process)

        #print "Found {0} processes".format(len(procs))

        # Get the info on each
        self.proc_infos = []
        for proc in procs:
            try:
                proc_as_dict = proc.as_dict()
                #print "proc_as_dict: {0}".format(proc_as_dict)
                for aspect in self.exclude:
                    proc_as_dict.pop(aspect, None)

                proc_info = self.plainify(proc_as_dict)
                #print "proc_info: {0}".format(proc_info)
                #print "before add_virt proc_info['pid']: {0}".format(proc_info.get('pid', None))
                self.add_virt_infos(proc_info)
                #print "snap v_t_r: {0}".format(proc_info['v_threads_running'])
                #print "after add_virt proc_info['pid']: {0}".format(proc_info.get('pid', None))
                self.proc_infos.append(proc_info)
            except:
                #print "Couldn't get proc: {0}".format(proc.pid)
                pass


    def add_virt_infos(self, proc):
        """Add derived data info to the process"""

        #print "add_virt_infos: cpu_percent: {0}".format(proc['cpu_percent'])
        # Add v_threads_running flag
        if self.is_running(proc):
            #print "proc {0} is running".format(proc)
            proc['v_threads_running'] = proc['num_threads']
        else:
            #print "proc {0} isn't running".format(proc)
            proc['v_threads_running'] = proc['num_threads']


    def plainify(self, obj):
        """Convert a given nested object containing structs and objects with custom fields,
        to a plain list, dict, literal, etc, with the custom fields as a dict"""

        out = None
        if isinstance(obj, str) or isinstance(obj, float) or isinstance(obj, int):
            out = obj

        elif isinstance(obj, list):
            out = [self.plainify(item) for item in obj]

        elif isinstance(obj, dict):
            out = {key: self.plainify(value) for key, value in obj.iteritems()}

        else:
            out = self.plainify(dict(zip(obj.__class__._fields, obj)))

        return out


    def is_running(self, process):
        """Guess whether this process has run since the last time we polled"""
        #print "is_running: cpu_percent: {0} threshold: {1}".format(process['cpu_percent'], DEFAULTS['cpu_threshold'])
        cpu_percent = process.get('cpu_percent', None)
        pid = process.get('pid', None)

        #print pid,cpu_percent,

        if cpu_percent is not None and pid is not None:
            running = cpu_percent > DEFAULTS['cpu_threshold']
        else:
            running = False
       
        return running


## Functions

def parse_args():
    """Parse given args"""
    parser = argparse.ArgumentParser(description='Profile a command')
    parser.add_argument('--cmd',
                        action='store',
                        help='Command to profile')
    parser.add_argument('--pid',
                        action='store',
                        type=int,
                        help='Process ID to profile')
    parser.add_argument('--max-polls',
                        action='store',
                        dest='max_polls',
                        default=DEFAULTS['max_polls'],
                        type=int,
                        help='Max number of polls. Default: {0}'.format(DEFAULTS['max_polls']))
    parser.add_argument('--poll-wait',
                        action='store',
                        dest='poll_wait',
                        default=DEFAULTS['poll_wait'],
                        type=float,
                        help='Wait time in seconds between polls. Can be a float. Default: {0}'.format(DEFAULTS['poll_wait']))
    parser.add_argument('-v',
                        action='count',
                        dest='verbosity',
                        default=DEFAULTS['verbosity'],
                        help='Increase the verbosity level')

    return parser.parse_args()


def main():
    """Main"""
    global ARGS
    ARGS = parse_args()

    if ARGS.cmd:
        profiler = Profiler(cmd=ARGS.cmd)
        profiler.run()

    elif ARGS.pid:
        profiler = Profiler(pid=ARGS.pid)

    else:
        print "You must specify --cmd or --pid"
        sys.exit(1)

    profiler.watch()


def rollup_dict(rolling_dict, obj):
    """Recursively roll up the given object (according to it's type), given a rollup obj
    previously created with this"""
    
    #print "rollup_dict({0}, {1})".format(rolling_dict, obj)

    if rolling_dict is None:
        rolling_dict = {}

    # Rollup each value in the dict
    for key, value in obj.iteritems():
        #print "Rolling up dict item {0}:{1}".format(key, value)
        # Init our rolling_dict, so we don't throw errors further on
        if key not in rolling_dict:
            rolling_dict[key] = None

        if isinstance(value, dict):
            # Case of a dict, rollup recursively
            #print "\n- Rolling up sub_dict rollup_dict({0}, {1})".format(rolling_dict.get(key, {}), value)

            sub_dict = rollup_dict(rolling_dict.get(key, {}), value)
            #print "Result: {0}:{1}\n".format(key, sub_dict)
            rolling_dict[key] = sub_dict

        elif isinstance(value, list):
            # Case of a list, rollup the length of the list
            rolling_dict[key] = rollup_obj(rolling_dict[key], len(value))

        elif isinstance(value, float) or isinstance(value, int) or isinstance(value, str):
            # Case of an immutable, roll it up
            rolling_dict[key] = rollup_obj(rolling_dict[key], value)

        elif value is None:
            pass
            #print "value is None??"

        else:
            raise "Unknown rollup_dict item type"

    #print "\n\nrollup_dict: returning {0}".format(rolling_dict)
    return rolling_dict


def filter_dict(given_obj, keys_to_remove):
    """Recursively walk the given obj and remove list of keys if it's a dict"""

    # Filter this if it's a dict
    if isinstance(given_obj, dict):
        for key in keys_to_remove:
            given_obj.pop(key, None)

    # Filter each value in the dict
    for key, value in given_obj.iteritems():
        #print "Filtering dict item {0}:{1}".format(key, value)

        if isinstance(value, dict):
            # Element is another dict, filter recursively
            filter_dict(given_obj[key], keys_to_remove)

    #print "\n\nrollup_dict: returning {0}".format(rolling_dict)
    return given_obj


def flatten_dict(given_obj, keys_to_replace):
    """Recursively walk the given obj and replace dict {given_keys: X} with their X values"""

    for key, value in given_obj.iteritems():
        #print "Flattening dict item {0}:{1}".format(key, value)
        if isinstance(value, dict):
            #print "{0} is a dict".format(key)
            replace_keys = list(set(value.keys()) & set(keys_to_replace))
            if len(replace_keys) > 0:
                #if key == 'v_threads_running':
                    #print "Collapsing {0} to {1}".format(key, value[replace_keys[0]])
                given_obj[key] = value[replace_keys[0]]
            else:
                # Element is another dict, filter recursively
                flatten_dict(given_obj[key], keys_to_replace)
        

    #print "\n\nrollup_dict: returning {0}".format(rolling_dict)
    return given_obj


def rollup_obj(rolling_obj, new_value):
    """ Rollup a given prev rollup dict, new value with (max, min, avg, accum)"""

    #print "rollup_obj({0}, {1})".format(rolling_obj, new_value)

    # Set result to something else, in these cases
    if rolling_obj is not None:
        rolling_obj['num_polls'] += 1

        if new_value > rolling_obj['max']:
            rolling_obj['max'] = new_value

        if new_value <  rolling_obj['min']:
            rolling_obj['min'] = new_value

        if not isinstance(rolling_obj['avg'], str) and not isinstance(new_value, str):
            rolling_obj['avg'] = (rolling_obj['avg'] * (rolling_obj['num_polls'] - 1) + new_value) / rolling_obj['num_polls']

        if not isinstance(rolling_obj['accum'], str) and not isinstance(new_value, str):
            rolling_obj['accum'] = rolling_obj['accum'] + new_value
            #print "Accumulated {0} + {1} = {2}".format(rolling_obj, new_value, result)

    else:
        # Initialize our rolling_obj object
        rolling_obj = {'max': new_value, 'avg': new_value, 'min': new_value, 'accum': new_value, 'num_polls': 1}

    #print "\n\nReturning result: {0}".format(rolling_obj)
    return rolling_obj


def test_rollup():
    rd = {}
    obj1 = {'cpu': 2, 'mem': {'top': 3}}
    rollup_dict(rd, obj1)
    pp.pprint(rd)
    print "\n"

    obj2 = {'cpu': 3, 'mem': {'top': 2}}
    rollup_dict(rd, obj2)
    pp.pprint(rd)
    print "\n"

    obj3 = {'cpu': 4, 'mem': {'top': 0}}
    rollup_dict(rd, obj3)
    pp.pprint(rd)
    print "\n"


    only_accum = filter_dict(rd, ['max', 'min', 'avg', 'num_polls'])
    pp.pprint(only_accum)

    only_accum = flatten_dict(rd, ['accum'])
    pp.pprint(only_accum)


## Main

#test_rollup()

main()
